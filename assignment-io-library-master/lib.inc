section .text

; Принимает код возврата и завершает текущий процесс
;Параметры:
;	rdi: код возврата
;Вывод:
;	!exit
exit:
	mov rax, 60			;'exit' syscall идентификатор
    	syscall

; Принимает указатель на нуль-терминированную строку, возвращает её длину
;Параметры:
;	rdi: указатель на нуль-терминированную строку
;Вывод:
;	rax: длина строки
string_length:
	xor rax, rax			;Устанавливаем 0 в rax
.loop:
    	cmp byte[rdi + rax], 0		;Проверяем на нуль-терминатор
    	jne .next			;Если не 0, то перейти
    	ret				;Иначе выход
.next:
    	inc rax			;Увеличиваем счетчик
    	jmp .loop			;Переходим к следующему символу

; Принимает указатель на нуль-терминированную строку, выводит её в stdout
;Параметры:
;	rdi: указатель на нуль-терминированную строку
;Вывод:
;	!stdout
print_string:
    	call string_length		;Получаем длину строки (в rax)
    	mov rsi, rdi			;Кладем адрес начала строки
    	mov rdx, rax			;Задаем кол-во байт для хранения
    	mov rdi, 1			;stdout file descriptor
    	mov rax, 1			;'write' syscall идентификатор
    	syscall
    	mov rax, 0			;Очищаем rax
   	ret

; Переводит строку (выводит символ с кодом 0xA)
;Параметры:
;	-
;Вывод:
;	!stdout
print_newline:
	mov rdi, 0xA			;Кладем нужный символ

; Принимает код символа и выводит его в stdout
;Параметры:
;	rdi: код символа
;Вывод:
;	!stdout
print_char:
    	mov rax, 1			;'write' syscall идентификатор
    	mov rdx, 1			;Выделяем память под 1 символ
    	push rdi			;Сохраняем значение rdi в стеке
    	mov rdi, 1			;stdout file descriptor
    	mov rsi, rsp			;Кладем ссылку на код символа
    	syscall
    	pop rdi			;Достаем значение rdi из стека
    	ret

; Выводит знаковое 8-байтовое число в десятичном формате 
;Параметры:
;	rdi: знаковое 8-байтовое число в десятичном формате
;Вывод:
;	!stdout
print_int:
    	cmp rdi, 0			;Сравниваем число с 0
    	jge print_uint			;Если >=0, то переход
    	push rdi			;Кладем число в стек
    	mov rdi, '-'			;Закидываем минус ('-') в rdi
    	call print_char		;Печатаем минус ('-')
    	pop rdi			;Достаем число из стека
    	neg rdi			;Приводим число к нужному виду

; Выводит беззнаковое 8-байтовое число в десятичном формате 
; Совет: выделите место в стеке и храните там результаты деления
; Не забудьте перевести цифры в их ASCII коды.
;Параметры:
;	rdi: беззнаковое 8-байтовое число в десятичном формате
;Вывод:
;	!stdout
print_uint:
	mov r9, rsp			;Сохраняем начальный указатель на вершину стека
	mov r10, 10			;Кладем делитель
	mov rax, rdi			;Кладем число, которое нужно перевести
	push 0				;Пушим 0, чтоб строка прочиталась как нуль-терминированная
.loop:
	mov rdx, 0			;Очищаем rdx
	div r10			;Делим число на делитель(10), остаток записывается в rdx
	add rdx, 0x30			;Переводим остаток в ASCII код
	dec rsp			;Сдвигаем указатель на стек
	mov byte[rsp], dl		;Сохраняем цифру в стеке
	cmp rax, 0			;Проверяем не закончилось ли число
	jnz .loop
	
	mov rdi, rsp			;Кладем адрес начала строки
	push r9			;Сохраняем значение r9
	call print_string		;Печатаем результат
	pop r9				;Достаем значение r9 из стека
	mov rsp, r9			;Возвращаем указатель стека в начальное состояние
    	ret

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
;Параметры:
;	rdi: указатель на первую нуль-терминированную строку
; 	rsi: указатель на вторую нуль-терминированную строку
;Вывод:
;	rax: результат
string_equals:
    	mov rax, 0			;Очищаем rax
	call string_length		;Находим длину первой строки
    	mov r10, rax			;Сохраняем длину первой строки
    	push rdi			;Кладем в стек указатель на первую строку
    	mov rdi, rsi			;Кладем в rdi указатель на вторую строку
    	pop rsi			;Кладем в rsi указатель на первую строку
    	call string_length		;Находим длину второй строки
    	cmp rax, r10			;Сравниваем длины строк
    	jne .noteq			;Если длины не равны, то переход
.loop:
	mov rax, 0			;Очищаем rax
	mov al, byte[rsi]		;Кладем младший байт первой строки
	cmp al, byte[rdi]		;Сравниваем символы двух строк
	jne .noteq			;Если не равны, то переход
	cmp al, 0			;Проверяем символ на нуль-терминант
	je .eq				;Если нуль-терминант, то строки равны -> переход
	inc rdi			;Сдвигаем указатель на вторую строку на следующий символ
	inc rsi			;Сдвигаем указатель на первую строку на следующий символ
	jmp .loop			;Переход в начало цикла
.noteq:
	mov rax, 0			;Кладем 0 в rax (0 - строки не равны)
    	ret
.eq:	
	mov rax, 1			;Кладем 1 в rax (1 - строки равны)
	ret  	

; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
;Параметры:
;	!stdin
;Вывод:
;	rax: введенный символ
read_char:
	push 0				;Если конец потока
	mov rax, 0			;'read' syscall идентификатор
    	mov rdx, 1			;Выделяем память под 1 символ
    	mov rdi, 0			;stdin file descriptor
    	mov rsi, rsp			;Кладем ссылку на символ
    	syscall
    	pop rax			;Кладем символ в rax
    	ret 

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0xA.
; Останавливается и возвращает 0 если слово слишком большое для буфера
; При успехе возвращает адрес буфера в rax, длину слова в rdx.
; При неудаче возвращает 0 в rax
; Эта функция должна дописывать к слову нуль-терминатор
;Параметры:
;	rdi: адрес начала буфера
;	rsi: размер буфера
;	!stdin
;Вывод:
;.при успехе:
;	rax: адрес буфера
;	rdx: длина слова
;.при неудаче:
;	rax: 0
read_word:
	push r12
	push r13
	push r14			;Сохраняем Callee-saved регистры
	mov r12, rdi			;Кладем адрес начала буфера
	mov r13, rsi			;Кладем размер буфера
	dec r13			;Уменьшаем размер буфера на 1 для нуль-терминатора
	mov r14, 0			;Счетчик прочитанных символов
.check_first:
	call read_char			;Читаем символ
	cmp rax, 0x0			;Проверяем на нуль-терминант
	je .exit			;Переход, если да
	cmp rax, 0x20			;Проверяем на пробел
	je .check_first		;Переход, если да
	cmp rax, 0x9			;Проверяем на табуляцию
	je .check_first		;Переход, если да
	cmp rax, 0xA			;Проверяем на перевод строки
	je .check_first		;Переход, если да
.loop:
	cmp rax, 0x0			;Проверяем на нуль-терминант
	je .exit			;Переход, если да
	cmp rax, 0x20			;Проверяем на пробел
	je .exit			;Переход, если да
	cmp rax, 0x9			;Проверяем на табуляцию
	je .exit			;Переход, если да
	cmp rax, 0xA			;Проверяем на перевод строки
	je .exit			;Переход, если да
	mov [r12+r14], al		;Кладем символ в буффер
	inc r14			;Инкрементируем счетчик прочитанных символов
	cmp r14, r13			;Сравниваем кол-во прочитанных символов с размером буфера
	jg .fail			;Переход, если кол-во прочитанных символов больше размера буфера
	call read_char			;Читаем символ
	jmp .loop			;Переход
.fail:
	pop r14
	pop r13
	pop r12
	mov rax, 0
	ret
.exit:
	mov byte[r12+r14], 0			
	mov rax, r12			;Кладем адрес буфера
	mov rdx, r14			;Кладем длину слова
	pop r14				
	pop r13
	pop r12			;Восстанавливаем Callee-saved регистры
	ret

; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
;Параметры:
;	rdi: указатель на строку
;Вывод:
;.если удалось прочитать:
;	rax: число
;	rdx: длина числа в символах
;.если не удалось прочитать:
;	rdx: 0;
parse_uint:
    	mov rax, 0			;Очищаем rax
    	mov r10, 10			;Кладем множитель (10)
    	mov r9, 0			;Счетчик символов
.loop:
	mov r8, 0			;Очищаем r8
	mov r8b, byte[rdi + r9]	;Читаем первый символ
	cmp r8b, 0x30			;Сравниваем код введенного символа с кодом '0'
	jb .exit			;Если код меньше 0 (т.е точно не цифра), то переход
	cmp r8b, 0x39			;Сравниваем код введенного символа с кодом '9'
	ja .exit			;Если код больше 9 (т.е точно не цифра), то переход
	sub r8b, 0x30			;Переводим из ASCII в десятичную цифру
	mul r10			;Умножаем число в rax на множитель (10)
	add rax, r8			;Прибавляем цифру к результату
	inc r9				;Инкрементируем счетчик символов
	jmp .loop			;Переход к следующему символу
.exit:
	mov rdx, r9			;Кладем длину числа в символах
    	ret


; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
;Параметры:
;	rdi: указатель на строку
;Вывод:
;.если удалось прочитать:
;	rax: число
;	rdx: длина числа в символах
;.если не удалось прочитать:
;	rdx: 0;
parse_int:
    	cmp byte[rdi], '-'		;Сравниваем первый символ с минусом ('-')
    	jne parse_uint			;Если первый знак - минус ('-'), то переход
    	inc rdi			;Сдвигаем указатель на следующий символ
    	call parse_uint		;Считываем число
    	inc rdx			;Инкрементируем счетчик символов, т.к. был зафиксирован минус ('-')
    	neg rax			;Приводим число к нужному виду
    	ret

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
;Параметры:
;	rdi: указатель на строку
;	rsi: указатель на буфер
;	rdx: длина буфера
;Вывод:
;	rax: длина строки
;	rax: 0 - если строка не умещается в буфер
string_copy:
	push rdi
	push rsi
	push rdx			;Сохраняем Caller-saved регистры
	call string_length		;Находим длину строки
	inc rax			;Инкрементируем rax, т.к. после строки добавляется еще нуль-терминатор
	pop rdx
	pop rsi
	pop rdi			;Восстанавливаем Caller-saved регистры
	cmp rax, rdx			;Сравниваем длину строки с длиной буфера
	jg .fail			;Если длина строки больше длины буфера, то переход
.loop:
	mov r8, 0			;Очищаем r8
	mov r8b, byte[rdi]		;Кладем символ в младший байт r8
	mov byte[rsi], r8b		;Кладем символ в буфер
	inc rdi			;Сдвигаем указатель на следующий символ
	inc rsi			;Сдвигаем указатель на следующую ячейку
	cmp r8b, 0			;Проверяем символ на нуль-терминант
	jne .loop			;Если не нуль-терминант - переход
	ret
.fail:
	mov rax, 0			;Кладем 0 в rax
	ret
